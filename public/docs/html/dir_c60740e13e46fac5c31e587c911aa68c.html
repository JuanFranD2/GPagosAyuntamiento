<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GPagosAyuntHin: C:/xampp/htdocs/GPagosAyuntamiento/vendor/guzzlehttp/promises Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GPagosAyuntHin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_c60740e13e46fac5c31e587c911aa68c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">promises Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-subdirs" class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:src" id="r_src"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_d1e3d4230d9dd9d2f39c41c086ad1451.html">src</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9326"></a>
Guzzle Promises</h1>
<p><a href="https://promisesaplus.com/">Promises/A+</a> implementation that handles promise chaining and resolution iteratively, allowing for "infinite" promise chaining while keeping the stack size constant. Read <a href="https://blog.domenic.me/youre-missing-the-point-of-promises/">this blog post</a> for a general introduction to promises.</p>
<ul>
<li>Features</li>
<li>Quick start</li>
<li>Synchronous wait</li>
<li>Cancellation</li>
<li>API<ul>
<li><a class="el" href="C:/xampp/htdocs/GPagosAyuntamiento/node_modules/fastq/README.md#promise">Promise</a></li>
<li>FulfilledPromise</li>
<li>RejectedPromise</li>
</ul>
</li>
<li>Promise interop</li>
<li>Implementation notes</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9327"></a>
Features</h1>
<ul>
<li><a href="https://promisesaplus.com/">Promises/A+</a> implementation.</li>
<li>Promise resolution and chaining is handled iteratively, allowing for "infinite" promise chaining.</li>
<li>Promises have a synchronous <span class="tt">wait</span> method.</li>
<li>Promises can be cancelled.</li>
<li>Works with any object that has a <span class="tt">then</span> function.</li>
<li>C# style async/await coroutine promises using <span class="tt"><a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\Coroutine::of()</span>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9328"></a>
Installation</h1>
<div class="fragment"><div class="line">composer require guzzlehttp/promises</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md9329"></a>
Version Guidance</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Version  </th><th class="markdownTableHeadNone">Status  </th><th class="markdownTableHeadNone">PHP Version  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1.x  </td><td class="markdownTableBodyNone">Security fixes only  </td><td class="markdownTableBodyNone">&gt;=5.5,&lt;8.3  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2.x  </td><td class="markdownTableBodyNone">Latest  </td><td class="markdownTableBodyNone">&gt;=7.2.5,&lt;8.5  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9330"></a>
Quick Start</h1>
<p>A <em>promise</em> represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its <span class="tt">then</span> method, which registers callbacks to receive either a promise's eventual value or the reason why the promise cannot be fulfilled.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9331"></a>
Callbacks</h2>
<p>Callbacks are registered with the <span class="tt">then</span> method by providing an optional <span class="tt">$onFulfilled</span> followed by an optional <span class="tt">$onRejected</span> function.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(</div>
<div class="line">    <span class="comment">// $onFulfilled</span></div>
<div class="line">    <span class="keyword">function</span> ($value) {</div>
<div class="line">        echo <span class="stringliteral">&#39;The promise was fulfilled.&#39;</span>;</div>
<div class="line">    },</div>
<div class="line">    <span class="comment">// $onRejected</span></div>
<div class="line">    <span class="keyword">function</span> ($reason) {</div>
<div class="line">        echo <span class="stringliteral">&#39;The promise was rejected.&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="ttc" id="aclass_guzzle_http_1_1_promise_1_1_promise_html"><div class="ttname"><a href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a></div><div class="ttdef"><b>Definition</b> Promise.php:15</div></div>
</div><!-- fragment --><p><em>Resolving</em> a promise means that you either fulfill a promise with a <em>value</em> or reject a promise with a <em>reason</em>. Resolving a promise triggers callbacks registered with the promise's <span class="tt">then</span> method. These callbacks are triggered only once and in the order in which they were added.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9332"></a>
Resolving a Promise</h2>
<p>Promises are fulfilled using the <span class="tt">resolve($value)</span> method. Resolving a promise with any value other than a <span class="tt"><a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\RejectedPromise</span> will trigger all of the onFulfilled callbacks (resolving a promise with a rejected promise will reject the promise and trigger the <span class="tt">$onRejected</span> callbacks).</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise</div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">        <span class="comment">// Return a value and don&#39;t break the chain</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Hello, &quot;</span> . $value;</div>
<div class="line">    })</div>
<div class="line">    <span class="comment">// This then is executed after the first then and receives the value</span></div>
<div class="line">    <span class="comment">// returned from the first then.</span></div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">        echo $value;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Resolving the promise triggers the $onFulfilled callbacks and outputs</span></div>
<div class="line"><span class="comment">// &quot;Hello, reader.&quot;</span></div>
<div class="line">$promise-&gt;resolve(<span class="stringliteral">&#39;reader.&#39;</span>);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9333"></a>
Promise Forwarding</h2>
<p>Promises can be chained one after the other. Each then in the chain is a new promise. The return value of a promise is what's forwarded to the next promise in the chain. Returning a promise in a <span class="tt">then</span> callback will cause the subsequent promises in the chain to only be fulfilled when the returned promise has been fulfilled. The next promise in the chain will be invoked with the resolved value of the promise.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$nextPromise = <span class="keyword">new</span> Promise();</div>
<div class="line"> </div>
<div class="line">$promise</div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) use ($nextPromise) {</div>
<div class="line">        echo $value;</div>
<div class="line">        <span class="keywordflow">return</span> $nextPromise;</div>
<div class="line">    })</div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">        echo $value;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Triggers the first callback and outputs &quot;A&quot;</span></div>
<div class="line">$promise-&gt;resolve(<span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line"><span class="comment">// Triggers the second callback and outputs &quot;B&quot;</span></div>
<div class="line">$nextPromise-&gt;resolve(<span class="charliteral">&#39;B&#39;</span>);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9334"></a>
Promise Rejection</h2>
<p>When a promise is rejected, the <span class="tt">$onRejected</span> callbacks are invoked with the rejection reason.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    echo $reason;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;Error!&#39;</span>);</div>
<div class="line"><span class="comment">// Outputs &quot;Error!&quot;</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9335"></a>
Rejection Forwarding</h2>
<p>If an exception is thrown in an <span class="tt">$onRejected</span> callback, subsequent <span class="tt">$onRejected</span> callbacks are invoked with the thrown exception as the reason.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception($reason);</div>
<div class="line">})-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    assert($reason-&gt;getMessage() === <span class="stringliteral">&#39;Error!&#39;</span>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;Error!&#39;</span>);</div>
</div><!-- fragment --><p>You can also forward a rejection down the promise chain by returning a <span class="tt"><a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\RejectedPromise</span> in either an <span class="tt">$onFulfilled</span> or <span class="tt">$onRejected</span> callback.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_rejected_promise.html">GuzzleHttp\Promise\RejectedPromise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> RejectedPromise($reason);</div>
<div class="line">})-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    assert($reason === <span class="stringliteral">&#39;Error!&#39;</span>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;Error!&#39;</span>);</div>
<div class="ttc" id="aclass_guzzle_http_1_1_promise_1_1_rejected_promise_html"><div class="ttname"><a href="class_guzzle_http_1_1_promise_1_1_rejected_promise.html">GuzzleHttp\Promise\RejectedPromise</a></div><div class="ttdef"><b>Definition</b> RejectedPromise.php:16</div></div>
</div><!-- fragment --><p>If an exception is not thrown in a <span class="tt">$onRejected</span> callback and the callback does not return a rejected promise, downstream <span class="tt">$onFulfilled</span> callbacks are invoked using the value returned from the <span class="tt">$onRejected</span> callback.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise</div>
<div class="line">    -&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;It&#39;s ok&quot;</span>;</div>
<div class="line">    })</div>
<div class="line">    -&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">        assert($value === <span class="stringliteral">&quot;It&#39;s ok&quot;</span>);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;Error!&#39;</span>);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md9336"></a>
Synchronous Wait</h1>
<p>You can synchronously force promises to complete using a promise's <span class="tt">wait</span> method. When creating a promise, you can provide a wait function that is used to synchronously force a promise to complete. When a wait function is invoked it is expected to deliver a value to the promise or reject the promise. If the wait function does not deliver a value, then an exception is thrown. The wait function provided to a promise constructor is invoked when the <span class="tt">wait</span> function of the promise is called.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> () use (&amp;$promise) {</div>
<div class="line">    $promise-&gt;resolve(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Calling wait will return the value of the promise.</span></div>
<div class="line">echo $promise-&gt;wait(); <span class="comment">// outputs &quot;foo&quot;</span></div>
</div><!-- fragment --><p>If an exception is encountered while invoking the wait function of a promise, the promise is rejected with the exception and the exception is thrown.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> () use (&amp;$promise) {</div>
<div class="line">    <span class="keywordflow">throw</span> <span class="keyword">new</span> Exception(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">$promise-&gt;wait(); <span class="comment">// throws the exception.</span></div>
</div><!-- fragment --><p>Calling <span class="tt">wait</span> on a promise that has been fulfilled will not trigger the wait function. It will simply return the previously resolved value.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> () { die(<span class="stringliteral">&#39;this is not called!&#39;</span>); });</div>
<div class="line">$promise-&gt;resolve(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line">echo $promise-&gt;wait(); <span class="comment">// outputs &quot;foo&quot;</span></div>
</div><!-- fragment --><p>Calling <span class="tt">wait</span> on a promise that has been rejected will throw an exception. If the rejection reason is an instance of <span class="tt">\Exception</span> the reason is thrown. Otherwise, a <span class="tt"><a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\RejectionException</span> is thrown and the reason can be obtained by calling the <span class="tt">getReason</span> method of the exception.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line">$promise-&gt;wait();</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>PHP Fatal error: Uncaught exception '<a class="el" href="namespace_guzzle_http.html">GuzzleHttp</a>\Promise\RejectionException' with message 'The promise was rejected with value: foo' </p>
</blockquote>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9337"></a>
Unwrapping a Promise</h2>
<p>When synchronously waiting on a promise, you are joining the state of the promise into the current state of execution (i.e., return the value of the promise if it was fulfilled or throw an exception if it was rejected). This is called "unwrapping" the promise. Waiting on a promise will by default unwrap the promise state.</p>
<p>You can force a promise to resolve and <em>not</em> unwrap the state of the promise by passing <span class="tt">false</span> to the first argument of the <span class="tt">wait</span> function:</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;reject(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line"><span class="comment">// This will not throw an exception. It simply ensures the promise has</span></div>
<div class="line"><span class="comment">// been resolved.</span></div>
<div class="line">$promise-&gt;wait(<span class="keyword">false</span>);</div>
</div><!-- fragment --><p>When unwrapping a promise, the resolved value of the promise will be waited upon until the unwrapped value is not a promise. This means that if you resolve promise A with a promise B and unwrap promise A, the value returned by the wait function will be the value delivered to promise B.</p>
<p><b>Note</b>: when you do not unwrap the promise, no value is returned.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9338"></a>
Cancellation</h1>
<p>You can cancel a promise that has not yet been fulfilled using the <span class="tt">cancel()</span> method of a promise. When creating a promise you can provide an optional cancel function that when invoked cancels the action of computing a resolution of the promise.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9339"></a>
API</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9340"></a>
Promise</h2>
<p>When creating a promise object, you can provide an optional <span class="tt">$waitFn</span> and <span class="tt">$cancelFn</span>. <span class="tt">$waitFn</span> is a function that is invoked with no arguments and is expected to resolve the promise. <span class="tt">$cancelFn</span> is a function with no arguments that is expected to cancel the computation of a promise. It is invoked when the <span class="tt">cancel()</span> method of a promise is called.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> Promise(</div>
<div class="line">    <span class="keyword">function</span> () use (&amp;$promise) {</div>
<div class="line">        $promise-&gt;resolve(<span class="stringliteral">&#39;waited&#39;</span>);</div>
<div class="line">    },</div>
<div class="line">    <span class="keyword">function</span> () {</div>
<div class="line">        <span class="comment">// do something that will cancel the promise computation (e.g., close</span></div>
<div class="line">        <span class="comment">// a socket, cancel a database query, etc...)</span></div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">assert(<span class="stringliteral">&#39;waited&#39;</span> === $promise-&gt;wait());</div>
</div><!-- fragment --><p>A promise has the following methods:</p>
<ul>
<li><p class="startli"><span class="tt">then(callable $onFulfilled, callable $onRejected) : PromiseInterface</span></p>
<p class="startli">Appends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler.</p>
</li>
<li><p class="startli"><span class="tt">otherwise(callable $onRejected) : PromiseInterface</span></p>
<p class="startli">Appends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.</p>
</li>
<li><p class="startli"><span class="tt">wait($unwrap = true) : mixed</span></p>
<p class="startli">Synchronously waits on the promise to complete.</p>
<p class="startli"><span class="tt">$unwrap</span> controls whether or not the value of the promise is returned for a fulfilled promise or if an exception is thrown if the promise is rejected. This is set to <span class="tt">true</span> by default.</p>
</li>
<li><p class="startli"><span class="tt">cancel()</span></p>
<p class="startli">Attempts to cancel the promise if possible. The promise being cancelled and the parent most ancestor that has not yet been resolved will also be cancelled. Any promises waiting on the cancelled promise to resolve will also be cancelled.</p>
</li>
<li><p class="startli"><span class="tt">getState() : string</span></p>
<p class="startli">Returns the state of the promise. One of <span class="tt">pending</span>, <span class="tt">fulfilled</span>, or <span class="tt">rejected</span>.</p>
</li>
<li><p class="startli"><span class="tt">resolve($value)</span></p>
<p class="startli">Fulfills the promise with the given <span class="tt">$value</span>.</p>
</li>
<li><p class="startli"><span class="tt">reject($reason)</span></p>
<p class="startli">Rejects the promise with the given <span class="tt">$reason</span>.</p>
</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9341"></a>
FulfilledPromise</h2>
<p>A fulfilled promise can be created to represent a promise that has been fulfilled.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_fulfilled_promise.html">GuzzleHttp\Promise\FulfilledPromise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> FulfilledPromise(<span class="stringliteral">&#39;value&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fulfilled callbacks are immediately invoked.</span></div>
<div class="line">$promise-&gt;then(<span class="keyword">function</span> ($value) {</div>
<div class="line">    echo $value;</div>
<div class="line">});</div>
<div class="ttc" id="aclass_guzzle_http_1_1_promise_1_1_fulfilled_promise_html"><div class="ttname"><a href="class_guzzle_http_1_1_promise_1_1_fulfilled_promise.html">GuzzleHttp\Promise\FulfilledPromise</a></div><div class="ttdef"><b>Definition</b> FulfilledPromise.php:16</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md9342"></a>
RejectedPromise</h2>
<p>A rejected promise can be created to represent a promise that has been rejected.</p>
<div class="fragment"><div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_rejected_promise.html">GuzzleHttp\Promise\RejectedPromise</a>;</div>
<div class="line"> </div>
<div class="line">$promise = <span class="keyword">new</span> RejectedPromise(<span class="stringliteral">&#39;Error&#39;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Rejected callbacks are immediately invoked.</span></div>
<div class="line">$promise-&gt;then(<span class="keyword">null</span>, <span class="keyword">function</span> ($reason) {</div>
<div class="line">    echo $reason;</div>
<div class="line">});</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md9343"></a>
Promise Interoperability</h1>
<p>This library works with foreign promises that have a <span class="tt">then</span> method. This means you can use Guzzle promises with <a href="https://github.com/reactphp/promise">React promises</a> for example. When a foreign promise is returned inside of a then method callback, promise resolution will occur recursively.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a React promise</span></div>
<div class="line">$deferred = <span class="keyword">new</span> React\Promise\Deferred();</div>
<div class="line">$reactPromise = $deferred-&gt;promise();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a Guzzle promise that is fulfilled with a React promise.</span></div>
<div class="line">$guzzlePromise = <span class="keyword">new</span> <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>();</div>
<div class="line">$guzzlePromise-&gt;then(<span class="keyword">function</span> ($value) use ($reactPromise) {</div>
<div class="line">    <span class="comment">// Do something something with the value...</span></div>
<div class="line">    <span class="comment">// Return the React promise</span></div>
<div class="line">    <span class="keywordflow">return</span> $reactPromise;</div>
<div class="line">});</div>
</div><!-- fragment --><p>Please note that wait and cancel chaining is no longer possible when forwarding a foreign promise. You will need to wrap a third-party promise with a Guzzle promise in order to utilize wait and cancel functions with foreign promises.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9344"></a>
Event Loop Integration</h2>
<p>In order to keep the stack size constant, Guzzle promises are resolved asynchronously using a task queue. When waiting on promises synchronously, the task queue will be automatically run to ensure that the blocking promise and any forwarded promises are resolved. When using promises asynchronously in an event loop, you will need to run the task queue on each tick of the loop. If you do not run the task queue, then promises will not be resolved.</p>
<p>You can run the task queue using the <span class="tt">run()</span> method of the global task queue instance.</p>
<div class="fragment"><div class="line"><span class="comment">// Get the global task queue</span></div>
<div class="line">$queue = <a class="code hl_function" href="class_guzzle_http_1_1_promise_1_1_utils.html#a4215e9a3cca6873dcc19f8fdbc039459">GuzzleHttp\Promise\Utils::queue</a>();</div>
<div class="line">$queue-&gt;run();</div>
<div class="ttc" id="aclass_guzzle_http_1_1_promise_1_1_utils_html_a4215e9a3cca6873dcc19f8fdbc039459"><div class="ttname"><a href="class_guzzle_http_1_1_promise_1_1_utils.html#a4215e9a3cca6873dcc19f8fdbc039459">GuzzleHttp\Promise\Utils\queue</a></div><div class="ttdeci">static queue(?TaskQueueInterface $assign=null)</div><div class="ttdef"><b>Definition</b> Utils.php:24</div></div>
</div><!-- fragment --><p>For example, you could use Guzzle promises with React using a periodic timer:</p>
<div class="fragment"><div class="line">$loop = React\EventLoop\Factory::create();</div>
<div class="line">$loop-&gt;addPeriodicTimer(0, [$queue, <span class="stringliteral">&#39;run&#39;</span>]);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md9345"></a>
Implementation Notes</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9346"></a>
Promise Resolution and Chaining is Handled Iteratively</h2>
<p>By shuffling pending handlers from one owner to another, promises are resolved iteratively, allowing for "infinite" then chaining.</p>
<div class="fragment"><div class="line">&lt;?<a class="code hl_namespace" href="namespacephp.html">php</a></div>
<div class="line">require <span class="stringliteral">&#39;vendor/autoload.php&#39;</span>;</div>
<div class="line"> </div>
<div class="line">use <a class="code hl_class" href="class_guzzle_http_1_1_promise_1_1_promise.html">GuzzleHttp\Promise\Promise</a>;</div>
<div class="line"> </div>
<div class="line">$parent = <span class="keyword">new</span> Promise();</div>
<div class="line">$p = $parent;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> ($i = 0; $i &lt; 1000; $i++) {</div>
<div class="line">    $p = $p-&gt;then(<span class="keyword">function</span> ($v) {</div>
<div class="line">        <span class="comment">// The stack size remains constant (a good thing)</span></div>
<div class="line">        echo xdebug_get_stack_depth() . <span class="stringliteral">&#39;, &#39;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> $v + 1;</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">$parent-&gt;resolve(0);</div>
<div class="line">var_dump($p-&gt;wait()); <span class="comment">// int(1000)</span></div>
<div class="ttc" id="anamespacephp_html"><div class="ttname"><a href="namespacephp.html">php</a></div></div>
</div><!-- fragment --><p>When a promise is fulfilled or rejected with a non-promise value, the promise then takes ownership of the handlers of each child promise and delivers values down the chain without using recursion.</p>
<p>When a promise is resolved with another promise, the original promise transfers all of its pending handlers to the new promise. When the new promise is eventually resolved, all of the pending handlers are delivered the forwarded value.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md9347"></a>
A Promise is the Deferred</h2>
<p>Some promise libraries implement promises using a deferred object to represent a computation and a promise object to represent the delivery of the result of the computation. This is a nice separation of computation and delivery because consumers of the promise cannot modify the value that will be eventually delivered.</p>
<p>One side effect of being able to implement promise resolution and chaining iteratively is that you need to be able for one promise to reach into the state of another promise to shuffle around ownership of handlers. In order to achieve this without making the handlers of a promise publicly mutable, a promise is also the deferred value, allowing promises of the same parent class to reach into and modify the private properties of promises of the same type. While this does allow consumers of the value to modify the resolution or rejection of the deferred, it is a small price to pay for keeping the stack size constant.</p>
<div class="fragment"><div class="line">$promise = <span class="keyword">new</span> Promise();</div>
<div class="line">$promise-&gt;then(<span class="keyword">function</span> ($value) { echo $value; });</div>
<div class="line"><span class="comment">// The promise is the deferred value, so you can deliver a value to it.</span></div>
<div class="line">$promise-&gt;resolve(<span class="stringliteral">&#39;foo&#39;</span>);</div>
<div class="line"><span class="comment">// prints &quot;foo&quot;</span></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md9348"></a>
Upgrading from Function API</h1>
<p>A static API was first introduced in 1.4.0, in order to mitigate problems with functions conflicting between global and local copies of the package. The function API was removed in 2.0.0. A migration table has been provided here for your convenience:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Original Function  </th><th class="markdownTableHeadNone">Replacement Method  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">queue</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::queue</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">task</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::task</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">promise_for</span>  </td><td class="markdownTableBodyNone"><span class="tt">Create::promiseFor</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">rejection_for</span>  </td><td class="markdownTableBodyNone"><span class="tt">Create::rejectionFor</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">exception_for</span>  </td><td class="markdownTableBodyNone"><span class="tt">Create::exceptionFor</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">iter_for</span>  </td><td class="markdownTableBodyNone"><span class="tt">Create::iterFor</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">inspect</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::inspect</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">inspect_all</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::inspectAll</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">unwrap</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::unwrap</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">all</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::all</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">some</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::some</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">any</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::any</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">settle</span>  </td><td class="markdownTableBodyNone"><span class="tt">Utils::settle</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">each</span>  </td><td class="markdownTableBodyNone"><span class="tt">Each::of</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">each_limit</span>  </td><td class="markdownTableBodyNone"><span class="tt">Each::ofLimit</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">each_limit_all</span>  </td><td class="markdownTableBodyNone"><span class="tt">Each::ofLimitAll</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">!is_fulfilled</span>  </td><td class="markdownTableBodyNone"><span class="tt">Is::pending</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">is_fulfilled</span>  </td><td class="markdownTableBodyNone"><span class="tt">Is::fulfilled</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">is_rejected</span>  </td><td class="markdownTableBodyNone"><span class="tt">Is::rejected</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">is_settled</span>  </td><td class="markdownTableBodyNone"><span class="tt">Is::settled</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">coroutine</span>  </td><td class="markdownTableBodyNone"><span class="tt">Coroutine::of</span>  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9349"></a>
Security</h1>
<p>If you discover a security vulnerability within this package, please send an email to <a href="#" onclick="location.href='mai'+'lto:'+'sec'+'ur'+'ity'+'@t'+'ide'+'li'+'ft.'+'co'+'m'; return false;">secur<span class="obfuscator">.nosp@m.</span>ity@<span class="obfuscator">.nosp@m.</span>tidel<span class="obfuscator">.nosp@m.</span>ift.<span class="obfuscator">.nosp@m.</span>com</a>. All security vulnerabilities will be promptly addressed. Please do not disclose security-related issues publicly until a fix has been announced. Please see <a href="https://github.com/guzzle/promises/security/policy">Security Policy</a> for more information.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9350"></a>
License</h1>
<p>Guzzle is made available under the MIT License (MIT). Please see [License <a class="el" href="class_file.html">File</a>](LICENSE) for more information.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md9351"></a>
For Enterprise</h1>
<p>Available as part of the Tidelift Subscription</p>
<p>The maintainers of Guzzle and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. <a href="https://tidelift.com/subscription/pkg/packagist-guzzlehttp-promises?utm_source=packagist-guzzlehttp-promises&amp;utm_medium=referral&amp;utm_campaign=enterprise&amp;utm_term=repo">Learn more.</a> </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_c5da75fdc1d6c57999112ed830c87a3c.html">vendor</a></li><li class="navelem"><a href="dir_db20eca0c4c216ce53e34984351e096a.html">guzzlehttp</a></li><li class="navelem"><a href="dir_c60740e13e46fac5c31e587c911aa68c.html">promises</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
